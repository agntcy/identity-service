// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"

	types0 "github.com/outshift/identity-service/internal/core/app/types"
	"github.com/outshift/identity-service/internal/core/policy/types"
	"github.com/outshift/identity-service/internal/pkg/pagination"
	mock "github.com/stretchr/testify/mock"
)

// NewRepository creates a new instance of Repository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *Repository {
	mock := &Repository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Repository is an autogenerated mock type for the Repository type
type Repository struct {
	mock.Mock
}

type Repository_Expecter struct {
	mock *mock.Mock
}

func (_m *Repository) EXPECT() *Repository_Expecter {
	return &Repository_Expecter{mock: &_m.Mock}
}

// CountAllPolicies provides a mock function for the type Repository
func (_mock *Repository) CountAllPolicies(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for CountAllPolicies")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_CountAllPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountAllPolicies'
type Repository_CountAllPolicies_Call struct {
	*mock.Call
}

// CountAllPolicies is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Repository_Expecter) CountAllPolicies(ctx interface{}) *Repository_CountAllPolicies_Call {
	return &Repository_CountAllPolicies_Call{Call: _e.mock.On("CountAllPolicies", ctx)}
}

func (_c *Repository_CountAllPolicies_Call) Run(run func(ctx context.Context)) *Repository_CountAllPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Repository_CountAllPolicies_Call) Return(n int64, err error) *Repository_CountAllPolicies_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *Repository_CountAllPolicies_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *Repository_CountAllPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function for the type Repository
func (_mock *Repository) Create(ctx context.Context, policy *types.Policy) error {
	ret := _mock.Called(ctx, policy)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.Policy) error); ok {
		r0 = returnFunc(ctx, policy)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type Repository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - policy *types.Policy
func (_e *Repository_Expecter) Create(ctx interface{}, policy interface{}) *Repository_Create_Call {
	return &Repository_Create_Call{Call: _e.mock.On("Create", ctx, policy)}
}

func (_c *Repository_Create_Call) Run(run func(ctx context.Context, policy *types.Policy)) *Repository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *types.Policy
		if args[1] != nil {
			arg1 = args[1].(*types.Policy)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_Create_Call) Return(err error) *Repository_Create_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_Create_Call) RunAndReturn(run func(ctx context.Context, policy *types.Policy) error) *Repository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRule provides a mock function for the type Repository
func (_mock *Repository) CreateRule(ctx context.Context, rule *types.Rule) error {
	ret := _mock.Called(ctx, rule)

	if len(ret) == 0 {
		panic("no return value specified for CreateRule")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.Rule) error); ok {
		r0 = returnFunc(ctx, rule)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_CreateRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRule'
type Repository_CreateRule_Call struct {
	*mock.Call
}

// CreateRule is a helper method to define mock.On call
//   - ctx context.Context
//   - rule *types.Rule
func (_e *Repository_Expecter) CreateRule(ctx interface{}, rule interface{}) *Repository_CreateRule_Call {
	return &Repository_CreateRule_Call{Call: _e.mock.On("CreateRule", ctx, rule)}
}

func (_c *Repository_CreateRule_Call) Run(run func(ctx context.Context, rule *types.Rule)) *Repository_CreateRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *types.Rule
		if args[1] != nil {
			arg1 = args[1].(*types.Rule)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_CreateRule_Call) Return(err error) *Repository_CreateRule_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_CreateRule_Call) RunAndReturn(run func(ctx context.Context, rule *types.Rule) error) *Repository_CreateRule_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTasks provides a mock function for the type Repository
func (_mock *Repository) CreateTasks(ctx context.Context, tasks ...*types.Task) error {
	// *types.Task
	_va := make([]interface{}, len(tasks))
	for _i := range tasks {
		_va[_i] = tasks[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTasks")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ...*types.Task) error); ok {
		r0 = returnFunc(ctx, tasks...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_CreateTasks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTasks'
type Repository_CreateTasks_Call struct {
	*mock.Call
}

// CreateTasks is a helper method to define mock.On call
//   - ctx context.Context
//   - tasks ...*types.Task
func (_e *Repository_Expecter) CreateTasks(ctx interface{}, tasks ...interface{}) *Repository_CreateTasks_Call {
	return &Repository_CreateTasks_Call{Call: _e.mock.On("CreateTasks",
		append([]interface{}{ctx}, tasks...)...)}
}

func (_c *Repository_CreateTasks_Call) Run(run func(ctx context.Context, tasks ...*types.Task)) *Repository_CreateTasks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []*types.Task
		variadicArgs := make([]*types.Task, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(*types.Task)
			}
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *Repository_CreateTasks_Call) Return(err error) *Repository_CreateTasks_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_CreateTasks_Call) RunAndReturn(run func(ctx context.Context, tasks ...*types.Task) error) *Repository_CreateTasks_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePolicies provides a mock function for the type Repository
func (_mock *Repository) DeletePolicies(ctx context.Context, policies ...*types.Policy) error {
	// *types.Policy
	_va := make([]interface{}, len(policies))
	for _i := range policies {
		_va[_i] = policies[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePolicies")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ...*types.Policy) error); ok {
		r0 = returnFunc(ctx, policies...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_DeletePolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePolicies'
type Repository_DeletePolicies_Call struct {
	*mock.Call
}

// DeletePolicies is a helper method to define mock.On call
//   - ctx context.Context
//   - policies ...*types.Policy
func (_e *Repository_Expecter) DeletePolicies(ctx interface{}, policies ...interface{}) *Repository_DeletePolicies_Call {
	return &Repository_DeletePolicies_Call{Call: _e.mock.On("DeletePolicies",
		append([]interface{}{ctx}, policies...)...)}
}

func (_c *Repository_DeletePolicies_Call) Run(run func(ctx context.Context, policies ...*types.Policy)) *Repository_DeletePolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []*types.Policy
		variadicArgs := make([]*types.Policy, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(*types.Policy)
			}
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *Repository_DeletePolicies_Call) Return(err error) *Repository_DeletePolicies_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_DeletePolicies_Call) RunAndReturn(run func(ctx context.Context, policies ...*types.Policy) error) *Repository_DeletePolicies_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePoliciesByAppID provides a mock function for the type Repository
func (_mock *Repository) DeletePoliciesByAppID(ctx context.Context, appID string) error {
	ret := _mock.Called(ctx, appID)

	if len(ret) == 0 {
		panic("no return value specified for DeletePoliciesByAppID")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, appID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_DeletePoliciesByAppID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePoliciesByAppID'
type Repository_DeletePoliciesByAppID_Call struct {
	*mock.Call
}

// DeletePoliciesByAppID is a helper method to define mock.On call
//   - ctx context.Context
//   - appID string
func (_e *Repository_Expecter) DeletePoliciesByAppID(ctx interface{}, appID interface{}) *Repository_DeletePoliciesByAppID_Call {
	return &Repository_DeletePoliciesByAppID_Call{Call: _e.mock.On("DeletePoliciesByAppID", ctx, appID)}
}

func (_c *Repository_DeletePoliciesByAppID_Call) Run(run func(ctx context.Context, appID string)) *Repository_DeletePoliciesByAppID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_DeletePoliciesByAppID_Call) Return(err error) *Repository_DeletePoliciesByAppID_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_DeletePoliciesByAppID_Call) RunAndReturn(run func(ctx context.Context, appID string) error) *Repository_DeletePoliciesByAppID_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRules provides a mock function for the type Repository
func (_mock *Repository) DeleteRules(ctx context.Context, rules ...*types.Rule) error {
	// *types.Rule
	_va := make([]interface{}, len(rules))
	for _i := range rules {
		_va[_i] = rules[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRules")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ...*types.Rule) error); ok {
		r0 = returnFunc(ctx, rules...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_DeleteRules_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRules'
type Repository_DeleteRules_Call struct {
	*mock.Call
}

// DeleteRules is a helper method to define mock.On call
//   - ctx context.Context
//   - rules ...*types.Rule
func (_e *Repository_Expecter) DeleteRules(ctx interface{}, rules ...interface{}) *Repository_DeleteRules_Call {
	return &Repository_DeleteRules_Call{Call: _e.mock.On("DeleteRules",
		append([]interface{}{ctx}, rules...)...)}
}

func (_c *Repository_DeleteRules_Call) Run(run func(ctx context.Context, rules ...*types.Rule)) *Repository_DeleteRules_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []*types.Rule
		variadicArgs := make([]*types.Rule, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(*types.Rule)
			}
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *Repository_DeleteRules_Call) Return(err error) *Repository_DeleteRules_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_DeleteRules_Call) RunAndReturn(run func(ctx context.Context, rules ...*types.Rule) error) *Repository_DeleteRules_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTasks provides a mock function for the type Repository
func (_mock *Repository) DeleteTasks(ctx context.Context, tasks ...*types.Task) error {
	// *types.Task
	_va := make([]interface{}, len(tasks))
	for _i := range tasks {
		_va[_i] = tasks[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTasks")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ...*types.Task) error); ok {
		r0 = returnFunc(ctx, tasks...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_DeleteTasks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTasks'
type Repository_DeleteTasks_Call struct {
	*mock.Call
}

// DeleteTasks is a helper method to define mock.On call
//   - ctx context.Context
//   - tasks ...*types.Task
func (_e *Repository_Expecter) DeleteTasks(ctx interface{}, tasks ...interface{}) *Repository_DeleteTasks_Call {
	return &Repository_DeleteTasks_Call{Call: _e.mock.On("DeleteTasks",
		append([]interface{}{ctx}, tasks...)...)}
}

func (_c *Repository_DeleteTasks_Call) Run(run func(ctx context.Context, tasks ...*types.Task)) *Repository_DeleteTasks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []*types.Task
		variadicArgs := make([]*types.Task, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(*types.Task)
			}
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *Repository_DeleteTasks_Call) Return(err error) *Repository_DeleteTasks_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_DeleteTasks_Call) RunAndReturn(run func(ctx context.Context, tasks ...*types.Task) error) *Repository_DeleteTasks_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTasksByAppID provides a mock function for the type Repository
func (_mock *Repository) DeleteTasksByAppID(ctx context.Context, appID string) error {
	ret := _mock.Called(ctx, appID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTasksByAppID")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, appID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_DeleteTasksByAppID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTasksByAppID'
type Repository_DeleteTasksByAppID_Call struct {
	*mock.Call
}

// DeleteTasksByAppID is a helper method to define mock.On call
//   - ctx context.Context
//   - appID string
func (_e *Repository_Expecter) DeleteTasksByAppID(ctx interface{}, appID interface{}) *Repository_DeleteTasksByAppID_Call {
	return &Repository_DeleteTasksByAppID_Call{Call: _e.mock.On("DeleteTasksByAppID", ctx, appID)}
}

func (_c *Repository_DeleteTasksByAppID_Call) Run(run func(ctx context.Context, appID string)) *Repository_DeleteTasksByAppID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_DeleteTasksByAppID_Call) Return(err error) *Repository_DeleteTasksByAppID_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_DeleteTasksByAppID_Call) RunAndReturn(run func(ctx context.Context, appID string) error) *Repository_DeleteTasksByAppID_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllPolicies provides a mock function for the type Repository
func (_mock *Repository) GetAllPolicies(ctx context.Context, paginationFilter pagination.PaginationFilter, query *string, appIDs []string, rulesForAppIDs []string) (*pagination.Pageable[types.Policy], error) {
	ret := _mock.Called(ctx, paginationFilter, query, appIDs, rulesForAppIDs)

	if len(ret) == 0 {
		panic("no return value specified for GetAllPolicies")
	}

	var r0 *pagination.Pageable[types.Policy]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, pagination.PaginationFilter, *string, []string, []string) (*pagination.Pageable[types.Policy], error)); ok {
		return returnFunc(ctx, paginationFilter, query, appIDs, rulesForAppIDs)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, pagination.PaginationFilter, *string, []string, []string) *pagination.Pageable[types.Policy]); ok {
		r0 = returnFunc(ctx, paginationFilter, query, appIDs, rulesForAppIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pagination.Pageable[types.Policy])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, pagination.PaginationFilter, *string, []string, []string) error); ok {
		r1 = returnFunc(ctx, paginationFilter, query, appIDs, rulesForAppIDs)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_GetAllPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllPolicies'
type Repository_GetAllPolicies_Call struct {
	*mock.Call
}

// GetAllPolicies is a helper method to define mock.On call
//   - ctx context.Context
//   - paginationFilter pagination.PaginationFilter
//   - query *string
//   - appIDs []string
//   - rulesForAppIDs []string
func (_e *Repository_Expecter) GetAllPolicies(ctx interface{}, paginationFilter interface{}, query interface{}, appIDs interface{}, rulesForAppIDs interface{}) *Repository_GetAllPolicies_Call {
	return &Repository_GetAllPolicies_Call{Call: _e.mock.On("GetAllPolicies", ctx, paginationFilter, query, appIDs, rulesForAppIDs)}
}

func (_c *Repository_GetAllPolicies_Call) Run(run func(ctx context.Context, paginationFilter pagination.PaginationFilter, query *string, appIDs []string, rulesForAppIDs []string)) *Repository_GetAllPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 pagination.PaginationFilter
		if args[1] != nil {
			arg1 = args[1].(pagination.PaginationFilter)
		}
		var arg2 *string
		if args[2] != nil {
			arg2 = args[2].(*string)
		}
		var arg3 []string
		if args[3] != nil {
			arg3 = args[3].([]string)
		}
		var arg4 []string
		if args[4] != nil {
			arg4 = args[4].([]string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *Repository_GetAllPolicies_Call) Return(pageable *pagination.Pageable[types.Policy], err error) *Repository_GetAllPolicies_Call {
	_c.Call.Return(pageable, err)
	return _c
}

func (_c *Repository_GetAllPolicies_Call) RunAndReturn(run func(ctx context.Context, paginationFilter pagination.PaginationFilter, query *string, appIDs []string, rulesForAppIDs []string) (*pagination.Pageable[types.Policy], error)) *Repository_GetAllPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllRules provides a mock function for the type Repository
func (_mock *Repository) GetAllRules(ctx context.Context, policyID string, paginationFilter pagination.PaginationFilter, query *string) (*pagination.Pageable[types.Rule], error) {
	ret := _mock.Called(ctx, policyID, paginationFilter, query)

	if len(ret) == 0 {
		panic("no return value specified for GetAllRules")
	}

	var r0 *pagination.Pageable[types.Rule]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, pagination.PaginationFilter, *string) (*pagination.Pageable[types.Rule], error)); ok {
		return returnFunc(ctx, policyID, paginationFilter, query)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, pagination.PaginationFilter, *string) *pagination.Pageable[types.Rule]); ok {
		r0 = returnFunc(ctx, policyID, paginationFilter, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pagination.Pageable[types.Rule])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, pagination.PaginationFilter, *string) error); ok {
		r1 = returnFunc(ctx, policyID, paginationFilter, query)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_GetAllRules_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllRules'
type Repository_GetAllRules_Call struct {
	*mock.Call
}

// GetAllRules is a helper method to define mock.On call
//   - ctx context.Context
//   - policyID string
//   - paginationFilter pagination.PaginationFilter
//   - query *string
func (_e *Repository_Expecter) GetAllRules(ctx interface{}, policyID interface{}, paginationFilter interface{}, query interface{}) *Repository_GetAllRules_Call {
	return &Repository_GetAllRules_Call{Call: _e.mock.On("GetAllRules", ctx, policyID, paginationFilter, query)}
}

func (_c *Repository_GetAllRules_Call) Run(run func(ctx context.Context, policyID string, paginationFilter pagination.PaginationFilter, query *string)) *Repository_GetAllRules_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 pagination.PaginationFilter
		if args[2] != nil {
			arg2 = args[2].(pagination.PaginationFilter)
		}
		var arg3 *string
		if args[3] != nil {
			arg3 = args[3].(*string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *Repository_GetAllRules_Call) Return(pageable *pagination.Pageable[types.Rule], err error) *Repository_GetAllRules_Call {
	_c.Call.Return(pageable, err)
	return _c
}

func (_c *Repository_GetAllRules_Call) RunAndReturn(run func(ctx context.Context, policyID string, paginationFilter pagination.PaginationFilter, query *string) (*pagination.Pageable[types.Rule], error)) *Repository_GetAllRules_Call {
	_c.Call.Return(run)
	return _c
}

// GetPoliciesByAppID provides a mock function for the type Repository
func (_mock *Repository) GetPoliciesByAppID(ctx context.Context, appID string) ([]*types.Policy, error) {
	ret := _mock.Called(ctx, appID)

	if len(ret) == 0 {
		panic("no return value specified for GetPoliciesByAppID")
	}

	var r0 []*types.Policy
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]*types.Policy, error)); ok {
		return returnFunc(ctx, appID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []*types.Policy); ok {
		r0 = returnFunc(ctx, appID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Policy)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, appID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_GetPoliciesByAppID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPoliciesByAppID'
type Repository_GetPoliciesByAppID_Call struct {
	*mock.Call
}

// GetPoliciesByAppID is a helper method to define mock.On call
//   - ctx context.Context
//   - appID string
func (_e *Repository_Expecter) GetPoliciesByAppID(ctx interface{}, appID interface{}) *Repository_GetPoliciesByAppID_Call {
	return &Repository_GetPoliciesByAppID_Call{Call: _e.mock.On("GetPoliciesByAppID", ctx, appID)}
}

func (_c *Repository_GetPoliciesByAppID_Call) Run(run func(ctx context.Context, appID string)) *Repository_GetPoliciesByAppID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_GetPoliciesByAppID_Call) Return(policys []*types.Policy, err error) *Repository_GetPoliciesByAppID_Call {
	_c.Call.Return(policys, err)
	return _c
}

func (_c *Repository_GetPoliciesByAppID_Call) RunAndReturn(run func(ctx context.Context, appID string) ([]*types.Policy, error)) *Repository_GetPoliciesByAppID_Call {
	_c.Call.Return(run)
	return _c
}

// GetPolicyByID provides a mock function for the type Repository
func (_mock *Repository) GetPolicyByID(ctx context.Context, id string) (*types.Policy, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetPolicyByID")
	}

	var r0 *types.Policy
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*types.Policy, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *types.Policy); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Policy)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_GetPolicyByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPolicyByID'
type Repository_GetPolicyByID_Call struct {
	*mock.Call
}

// GetPolicyByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *Repository_Expecter) GetPolicyByID(ctx interface{}, id interface{}) *Repository_GetPolicyByID_Call {
	return &Repository_GetPolicyByID_Call{Call: _e.mock.On("GetPolicyByID", ctx, id)}
}

func (_c *Repository_GetPolicyByID_Call) Run(run func(ctx context.Context, id string)) *Repository_GetPolicyByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_GetPolicyByID_Call) Return(policy *types.Policy, err error) *Repository_GetPolicyByID_Call {
	_c.Call.Return(policy, err)
	return _c
}

func (_c *Repository_GetPolicyByID_Call) RunAndReturn(run func(ctx context.Context, id string) (*types.Policy, error)) *Repository_GetPolicyByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetRuleByID provides a mock function for the type Repository
func (_mock *Repository) GetRuleByID(ctx context.Context, ruleID string, policyID string) (*types.Rule, error) {
	ret := _mock.Called(ctx, ruleID, policyID)

	if len(ret) == 0 {
		panic("no return value specified for GetRuleByID")
	}

	var r0 *types.Rule
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) (*types.Rule, error)); ok {
		return returnFunc(ctx, ruleID, policyID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) *types.Rule); ok {
		r0 = returnFunc(ctx, ruleID, policyID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Rule)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = returnFunc(ctx, ruleID, policyID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_GetRuleByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRuleByID'
type Repository_GetRuleByID_Call struct {
	*mock.Call
}

// GetRuleByID is a helper method to define mock.On call
//   - ctx context.Context
//   - ruleID string
//   - policyID string
func (_e *Repository_Expecter) GetRuleByID(ctx interface{}, ruleID interface{}, policyID interface{}) *Repository_GetRuleByID_Call {
	return &Repository_GetRuleByID_Call{Call: _e.mock.On("GetRuleByID", ctx, ruleID, policyID)}
}

func (_c *Repository_GetRuleByID_Call) Run(run func(ctx context.Context, ruleID string, policyID string)) *Repository_GetRuleByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Repository_GetRuleByID_Call) Return(rule *types.Rule, err error) *Repository_GetRuleByID_Call {
	_c.Call.Return(rule, err)
	return _c
}

func (_c *Repository_GetRuleByID_Call) RunAndReturn(run func(ctx context.Context, ruleID string, policyID string) (*types.Rule, error)) *Repository_GetRuleByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetTasksByAppID provides a mock function for the type Repository
func (_mock *Repository) GetTasksByAppID(ctx context.Context, appID string) ([]*types.Task, error) {
	ret := _mock.Called(ctx, appID)

	if len(ret) == 0 {
		panic("no return value specified for GetTasksByAppID")
	}

	var r0 []*types.Task
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]*types.Task, error)); ok {
		return returnFunc(ctx, appID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []*types.Task); ok {
		r0 = returnFunc(ctx, appID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Task)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, appID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_GetTasksByAppID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTasksByAppID'
type Repository_GetTasksByAppID_Call struct {
	*mock.Call
}

// GetTasksByAppID is a helper method to define mock.On call
//   - ctx context.Context
//   - appID string
func (_e *Repository_Expecter) GetTasksByAppID(ctx interface{}, appID interface{}) *Repository_GetTasksByAppID_Call {
	return &Repository_GetTasksByAppID_Call{Call: _e.mock.On("GetTasksByAppID", ctx, appID)}
}

func (_c *Repository_GetTasksByAppID_Call) Run(run func(ctx context.Context, appID string)) *Repository_GetTasksByAppID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_GetTasksByAppID_Call) Return(tasks []*types.Task, err error) *Repository_GetTasksByAppID_Call {
	_c.Call.Return(tasks, err)
	return _c
}

func (_c *Repository_GetTasksByAppID_Call) RunAndReturn(run func(ctx context.Context, appID string) ([]*types.Task, error)) *Repository_GetTasksByAppID_Call {
	_c.Call.Return(run)
	return _c
}

// GetTasksByID provides a mock function for the type Repository
func (_mock *Repository) GetTasksByID(ctx context.Context, ids []string) ([]*types.Task, error) {
	ret := _mock.Called(ctx, ids)

	if len(ret) == 0 {
		panic("no return value specified for GetTasksByID")
	}

	var r0 []*types.Task
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []string) ([]*types.Task, error)); ok {
		return returnFunc(ctx, ids)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, []string) []*types.Task); ok {
		r0 = returnFunc(ctx, ids)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Task)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = returnFunc(ctx, ids)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_GetTasksByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTasksByID'
type Repository_GetTasksByID_Call struct {
	*mock.Call
}

// GetTasksByID is a helper method to define mock.On call
//   - ctx context.Context
//   - ids []string
func (_e *Repository_Expecter) GetTasksByID(ctx interface{}, ids interface{}) *Repository_GetTasksByID_Call {
	return &Repository_GetTasksByID_Call{Call: _e.mock.On("GetTasksByID", ctx, ids)}
}

func (_c *Repository_GetTasksByID_Call) Run(run func(ctx context.Context, ids []string)) *Repository_GetTasksByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []string
		if args[1] != nil {
			arg1 = args[1].([]string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_GetTasksByID_Call) Return(tasks []*types.Task, err error) *Repository_GetTasksByID_Call {
	_c.Call.Return(tasks, err)
	return _c
}

func (_c *Repository_GetTasksByID_Call) RunAndReturn(run func(ctx context.Context, ids []string) ([]*types.Task, error)) *Repository_GetTasksByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetTasksPerAppType provides a mock function for the type Repository
func (_mock *Repository) GetTasksPerAppType(ctx context.Context, excludeAppIDs ...string) (map[types0.AppType][]*types.Task, error) {
	// string
	_va := make([]interface{}, len(excludeAppIDs))
	for _i := range excludeAppIDs {
		_va[_i] = excludeAppIDs[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTasksPerAppType")
	}

	var r0 map[types0.AppType][]*types.Task
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ...string) (map[types0.AppType][]*types.Task, error)); ok {
		return returnFunc(ctx, excludeAppIDs...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ...string) map[types0.AppType][]*types.Task); ok {
		r0 = returnFunc(ctx, excludeAppIDs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[types0.AppType][]*types.Task)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ...string) error); ok {
		r1 = returnFunc(ctx, excludeAppIDs...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_GetTasksPerAppType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTasksPerAppType'
type Repository_GetTasksPerAppType_Call struct {
	*mock.Call
}

// GetTasksPerAppType is a helper method to define mock.On call
//   - ctx context.Context
//   - excludeAppIDs ...string
func (_e *Repository_Expecter) GetTasksPerAppType(ctx interface{}, excludeAppIDs ...interface{}) *Repository_GetTasksPerAppType_Call {
	return &Repository_GetTasksPerAppType_Call{Call: _e.mock.On("GetTasksPerAppType",
		append([]interface{}{ctx}, excludeAppIDs...)...)}
}

func (_c *Repository_GetTasksPerAppType_Call) Run(run func(ctx context.Context, excludeAppIDs ...string)) *Repository_GetTasksPerAppType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []string
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *Repository_GetTasksPerAppType_Call) Return(appTypeToTasks map[types0.AppType][]*types.Task, err error) *Repository_GetTasksPerAppType_Call {
	_c.Call.Return(appTypeToTasks, err)
	return _c
}

func (_c *Repository_GetTasksPerAppType_Call) RunAndReturn(run func(ctx context.Context, excludeAppIDs ...string) (map[types0.AppType][]*types.Task, error)) *Repository_GetTasksPerAppType_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePolicy provides a mock function for the type Repository
func (_mock *Repository) UpdatePolicy(ctx context.Context, policy *types.Policy) error {
	ret := _mock.Called(ctx, policy)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePolicy")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.Policy) error); ok {
		r0 = returnFunc(ctx, policy)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_UpdatePolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePolicy'
type Repository_UpdatePolicy_Call struct {
	*mock.Call
}

// UpdatePolicy is a helper method to define mock.On call
//   - ctx context.Context
//   - policy *types.Policy
func (_e *Repository_Expecter) UpdatePolicy(ctx interface{}, policy interface{}) *Repository_UpdatePolicy_Call {
	return &Repository_UpdatePolicy_Call{Call: _e.mock.On("UpdatePolicy", ctx, policy)}
}

func (_c *Repository_UpdatePolicy_Call) Run(run func(ctx context.Context, policy *types.Policy)) *Repository_UpdatePolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *types.Policy
		if args[1] != nil {
			arg1 = args[1].(*types.Policy)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_UpdatePolicy_Call) Return(err error) *Repository_UpdatePolicy_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_UpdatePolicy_Call) RunAndReturn(run func(ctx context.Context, policy *types.Policy) error) *Repository_UpdatePolicy_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateRule provides a mock function for the type Repository
func (_mock *Repository) UpdateRule(ctx context.Context, rule *types.Rule) error {
	ret := _mock.Called(ctx, rule)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRule")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.Rule) error); ok {
		r0 = returnFunc(ctx, rule)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_UpdateRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRule'
type Repository_UpdateRule_Call struct {
	*mock.Call
}

// UpdateRule is a helper method to define mock.On call
//   - ctx context.Context
//   - rule *types.Rule
func (_e *Repository_Expecter) UpdateRule(ctx interface{}, rule interface{}) *Repository_UpdateRule_Call {
	return &Repository_UpdateRule_Call{Call: _e.mock.On("UpdateRule", ctx, rule)}
}

func (_c *Repository_UpdateRule_Call) Run(run func(ctx context.Context, rule *types.Rule)) *Repository_UpdateRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *types.Rule
		if args[1] != nil {
			arg1 = args[1].(*types.Rule)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_UpdateRule_Call) Return(err error) *Repository_UpdateRule_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_UpdateRule_Call) RunAndReturn(run func(ctx context.Context, rule *types.Rule) error) *Repository_UpdateRule_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateTasks provides a mock function for the type Repository
func (_mock *Repository) UpdateTasks(ctx context.Context, tasks ...*types.Task) error {
	// *types.Task
	_va := make([]interface{}, len(tasks))
	for _i := range tasks {
		_va[_i] = tasks[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _mock.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTasks")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ...*types.Task) error); ok {
		r0 = returnFunc(ctx, tasks...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_UpdateTasks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateTasks'
type Repository_UpdateTasks_Call struct {
	*mock.Call
}

// UpdateTasks is a helper method to define mock.On call
//   - ctx context.Context
//   - tasks ...*types.Task
func (_e *Repository_Expecter) UpdateTasks(ctx interface{}, tasks ...interface{}) *Repository_UpdateTasks_Call {
	return &Repository_UpdateTasks_Call{Call: _e.mock.On("UpdateTasks",
		append([]interface{}{ctx}, tasks...)...)}
}

func (_c *Repository_UpdateTasks_Call) Run(run func(ctx context.Context, tasks ...*types.Task)) *Repository_UpdateTasks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []*types.Task
		variadicArgs := make([]*types.Task, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(*types.Task)
			}
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *Repository_UpdateTasks_Call) Return(err error) *Repository_UpdateTasks_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_UpdateTasks_Call) RunAndReturn(run func(ctx context.Context, tasks ...*types.Task) error) *Repository_UpdateTasks_Call {
	_c.Call.Return(run)
	return _c
}
